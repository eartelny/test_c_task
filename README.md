# пояснительная записка

## состав пакета
server.c - код , где создается UDP сокет и ведется прием данных в него. Там же парсер
clientUDP.c - тестовый клиент, отправляющий 5 нормальных и 2 неизвестных мессаджа одной посылкой. 

## компиляция
(env:  чистая ubuntu 18.04 desktop и плюс в дополнение к нему сделано apt-get install gcc):
gcc -std=c11 -o server server.c
gcc -o client clientUDP.c

## запуск
в разных консолях запустить server и client. Оценить вывод сервера. ожидаемый вывод сервера примерно такой ( вываливается на каждый запуск клиента. и дальше сервер ждет новой посылки пока его не остановить ctrl+C):

    earteny@earteny-VirtualBox:~/prima$ ./server
    press ctrl+C to exit
    Type: 0 Len: 1 Value: 1
    
    Type: 0 Len: 1 Value: 0
    
    Type: 2 Len: 0 Value: SKIPPED
    Type: 1 Len: 2 Value: rx
    
    Type: 2 Len: 3 Value: SKIPPED
    Type: 1 Len: 2 Value: tx
    
    Type: 1 Len: 4 Value: rxtx
    
    
    
    

## реализованный функционал
создается UDP сокет, в который ведется прием TLV сообщений согласно ТЗ (два известных типа сообщения - режим работы трансивера и вежим работы усилителя).
по мере приема пакетов, они парсятся , и если тип соощения известен - то оно выплевывается в stdout. в stderr при этом логируется строка вида
Type: <тип> Len: <длина> Value: <значение>
если тип неизвестен, то в поле Value стоит значение SKIPPED, оригинал сообщения не передается в stdout.

## нереализованный функционал
- надо бы обернуть в POLL либо select чтение из UDP сокета (тогда можно будет реализовать правильный "неблокирующий функционал")
- код не приведен к единому code style и синтаксически грязноват - это следствие того, что давно на С не писал и уже подзабыл как там что использовать.
- в некоторых местах неоптимальная реализация, где-то помечена TODO с комментариями.
- код отлажен для базовых сценариев штатной работы (известные + неизвестные посылки, правильно сформированные), но не выверен на работу со всеми возможными типами ошибочных данных.
- не покрыт юнит тестами.
- не отлажет под нагрузкой и длительной работой - возможны memory leaks :)
- также возможно потребуется дополнительная настройка для запуска с какими-нибудь неполными glibc или урезанными коспиляторами - в тз конкретики не было насчет дополнительных платформ.
- общий код для client и server не вынесен в отдельный модуль
- по расширяемости - ну пока оставил возможность добавить значений в enum `TlvType` - и дальше по switch в методе `readNextTLVFragment` . В целом если посидеть-подумать, то можно и покрасивее сделать. 

## почему есть нереализованный функционал?
мне через два дня уже, условно говоря, на самолет. Если бы я потратил еще два дня на чистку - то мне уже неактуальна Ваша вакансия будет. Так что потратил 8 часов , а оставшееся время вам на раздумья - поверите вы , что мне удастся в production аналогичный кода реализовать, или же нет :) 


------------

Ну и в заключении - огромное спасибо за тестовое задание, было очень приятно повспомитать особенности работы с указателями, работу с выделением памяти, с сокетами и gdb. 
